# 김준호 202330208 


## 5월 3일
■ 컬렉션 
    -요소라고 불리는 가변 개수의 객체들의 저장소, 
    -고정 크기의 배열을 다루는 어려움 해소, 
    -다양한 객체들의 삽입, 삭제, 등의 관리 용이

■ 컬렉션은 "제너릭" 기법으로 구현    
    ●제너릭 - 특정 타임만 다루지 않고, 여러 종류의 타입으로 변실할 수 있도록 클래스나 메소드를 일반화시키는 기법
           - JDK 1.5부터 도입
           - C++의 템플릿과 동일
    
    ●제너릭 컬렉션 사례 : 벡터 Vector<E>
        -정수만 다루는 컬렉션 벡터 Vector<Integer>
        -문자열만 다루는 컬렉션 벡터 Vector<String>       

■ 컬렉션의 요소는 객체만 가능
    -int, char, double등의 기본 타입으로 구체화 불가

■ Vector<E>의 특성
    - <E>에 사용할 요소의 특정 타입으로 구체화
    - 배열을 가변 크기로 다룰 수 있게 하는 컨테이너
    - 요소 객체들을 삽입, 삭제, 검색하는 컨테이너
    - Vector의 삽입 가능한 것 => 객체, null, 기본 타입의 값은 Wrapper객체로 만들어 저장 
    - Vector의 객체 삽입 => 벡터의 맨 뒤, 중간에 객체 삽입 가능
    - Vector의 객체 삭제 => 임의의 위치에 있는 객체 삭제 가능

■ 컬렉션과 자동 박싱/언박싱 
    - 1.5 이전 : 기본 타입 데이터를 Wrapper 객체로 만들어 삽입    
    - 1.5 이후 : 자동 박싱/언박싱이 작동하여 기본 타입 값 삽입 가능

■ ArrayList<E> 
    - 가변 크기 배열을 구현한 클래스
    - 벡터와 거의 동일 

■ 컬렉션의 순차 검색을 위한 Iterator
    - Iterator<E> 인터페이스 => 리스트 구조의 컬렉션에서 요소의 순차 검색을 위한 인터페이스
    - Iterator 객체 얻어내기 => 컬렉션의 iterator() 메소드 호출

■ HashMap<K,V>
    ● 키(key)와 값(value)의 쌍으로 구성되는 요소를 다루는 컬렉션
        - 키와 값이 한 쌍으로 삽입
        - '값'을 검색하기 위해서는 반드시 '키' 이용

    ● 삽입 및 검색이 빠른 특징 
        - 요소 삽입 : put() 메소드
        - 요소 검색 : get() 메소드

■ 자바의 GUI
    ● GUI 
        - 사용자가 관리하게 입출력 할 수 있도록 그래픽으로 화면을 구성하고, 마우스나 키보드로 입력 받을 수 있도록
            지원하는 사용자 인터페이스 

    ● 자바 언어에서 GUI 응용프로그램 작성
        - AWT와 Swing 패키지에 강력한 GUI 컴포넌트 제공
        - 쉬운 GUI 프로그래밍

    ◆ AWT와 Swing 패키지
        ● AWT 패키지 - 자바가 처음 나왔을 때부터 배포된 GUI 패키지, 최근에는 거의 사용하지 않음
                   - AWT 컴포넌트는 중량 컴포넌트
 
        ● Swing 패키지 - AWT 기술을 기반으로 작성된 자바 라이브러리
                       - 모든 AWT 기능 + 추가된 풍부하고 화려한 고급 컴포넌트 

■ 컨테이너
    - 다른 컴포넌트를 포함할 수 있는 GUI 컴포넌트
    - 다른 컨테이너에 포함될 수 있음

■ 컴포넌트 
    - 컨테이너에 포함되어야 화면에 출력될 수 있는 GUI 객체
    - 다른 컴포넌트를 포함할 수 없는 순수 컴포넌트    

■ 최상위 컨테이너
    - 다른 컨테이너에 포함되지 않고도 화면에 출력되며 독립적으로 존재 가능한 컨테이너

■ 스윙 GUI 프로그램을 만드는 과정
    1. 스윙 프레임 만들기
    2. main() 메소드 작성
    3. 스윙 프레임에 스윙 컴포넌트 붙이기

■ 스윙 프레임 
    - 모든 스윙 컴포넌트를 담는 최상위 컨테이너
    - JFrame을 상속받아 구현
    - 프레임의 크기 반드시 지정 : setSize() 호출





## 4월 19일
■ 메소드 오버라이딩 - 서브 클래스에서 슈퍼 클래스에 선언된 메소드를 중복 작성하여 슈퍼 클래스에 작성된 메소드를 무력화 시키고 객체의 주인노릇을 함

■ 목적 - 오버라이딩으로 다형성 실현, 하나의 인터페이스에도 서로 다른 구현
■ 동적 바인딩 - 오버라이딩된 메소드 호출
■ super키워드로 슈퍼 클래스의 멤버 접근

■ 추상 메소드 - abstract로 선언한 메소드의 코드는 없고 원형만 선언
■ 추상 클래스 - 추상 메소드를 가지며, abstract로 선언된 클래스, 추상 메소드 없이 abstract로 선언한 클래스
■ 추상 클래스는 온전한 클래스가 아니기 때문에 인스턴스를 생성할 수 없음
■ 추상 클래스 상속 - 추상 클래스를 상속받으면 추상 클래스가 됨, 서브 클래스도 abstract로 선언해야 함
■ 추상 클래스 구현 - 서브 클래스에서 슈퍼 클래스의 추상 메소드 구현, 추상 클래스를 구현한 서브 클래스는 추상 클래스 아님
■ 추상 클래스의 목적 - 상속을 위한 슈퍼 클래스로 활용하는 것, 서브 클래스에서 추상 메소드 구현, 다형성 실현

■ 자바의 인터페이스 - 클래스가 구현해야 할 메소드들이 선언되는 추상형 
■ 인터페이스 선언 - interface 키워드로 선언  
■ 자바 인터페이스에 대한 변화 - 여전히 인터페이스에는 필드(멤버 변수) 선언 불가
■ 자바 인터페이스 특징 - 인터페이스의 객체 생성 불가
■ 인터페이스 상속 - 인터페이스 간에 상속 가능, 인터페이스 다중 상속 허용

■ 자바의 패키지와 모듈 - 
    패키지 - 하나의 응용프로그램은 한 개 이상의 패키지로 작성, 서로 관련된 클래스와 인터페이스를 컴파일한 클래스 파일들을 묶어 놓은 디렉토리

    모듈 - 여러 패키지와 이미지 등의 자원을 모아 놓은 컨테이너, 하나의 모듈을 하나의 .jmod 파일에 저장  

■ 모듈화의 목적 - java9부터 자바 api를 여러 모듈로 분할
■ 모듈의 현실 - 복잡한 개념, 큰 자바 응용 프로그램에는 개발, 유지보수 등에 적합, 현실적으로 모듈로 나누어 자바         
    프로그램을 작성할 필요 없음 

■ 패키지 만들기 - 클래스 파일이 저장되는 위치는 클래스나 인터페이스가 컴파일되면 클래스 파일 생성, 클래스 파일은       
                패키지로 선언된 디렉토리에 저장

■ 패키지 선언 - 소스 파일의 맨 앞에 컴파일 후 저장될 패키지 지정
■ 모듈 개념 - 패키지와 이미지 등의 리소스를 담은 컨테이너
■ 모듈화의 목적 - 큰 컴포넌트들을 필요에 따라 조립하여 사용하기 위함

■ object 클래스 특징 - 모든 자바 클래스는 반드시 object를 상속 받도록 자동 컴파일, 모든 클래스의 슈퍼 클래스
■ 객체 속성 - object 클래스는 객체의 속성을 나타내는 메소드 제공

■ 객체 비교(==)와 equal()메소드
    ==연산자 - 객체 래퍼런스 비교
    boolean equals(Object obj) - 두 객체의 내용을 비교

■ Wrapper클래스 - 자바의 기본 타입을 클래스화한 8개 클래스를 통칭
    용도 - 객체만 사용할 수 있는 컬렉션 등에 기본 타입의 값을 사용하기 위해->Wrapper 객체로 만들어 사용

■ 박싱 - 기본 타입의 값을 Wrapper 객체로 변환하는 것
■ 언박싱 - Wrapper 객체에 들어 있는 기본 타입의 값을 빼내는 것
■ 스트링 리터럴 - 자바 가상 기계 내부에서 리터럴 테이블에 저장되고 관리함



## 4월 12일
■ 자바의 접근 지정자 - private public protected 디폴트(접근 지정자 생략)
■ 접근 지정자의 목적 - 클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용
■ 클래스 접근지정 - 다른 클래스에서 사용하도록 허용할 지 지정
               - public 클래스
               - 디폴트 클래스(접근지정자 생략)

■ public 멤버 - 패키지에 관계 없이 모든 클래스에게 접근 허용

■ pirvate 멤버 - 동일 클래스 내에만 접근 허용, 상속 받은 서브 클래스에서 접근 불가

■ protected 멤버 - 같은 패키지 내의 다른 모든 클래스에게 접근 허용, 상속 받은 서브 클래스는 다른 패키지에 있어도 접근 가능

■ 디폴트 멤버 - 같은 패키지 내의 다른 클래스에게 접근 허용

■ static 멤버 - static 멤버는 클래스당 하나만 생성, 객체들에 의해 공유됨
■ static 멤버 사용 - 클래스 이름으로 접근 가능, 객체의 멤버로 접근 가능 non static 멤버는 클래스 이름으로 접근 안됨

■ final 필드 - final 필드 실수 선언(상수를 선언할 때 사용, 상수 필드는 선언 시에 초기 값을 지정하여야 한다, 실행 중에 값을 바꿀 수 없다)

P.191
■ 상속 선언 - extends 키워드로 선언, 부모 클래스 -> 슈퍼 클래스, 자식 클래스 -> 서브 클래스
■ 자바 상속의 특징 - 클래스 다중 상속 불허, 모든 자바 클래스는 묵시적으로 object클래스 상속 받음
■ 슈퍼 클래스의 멤버에 대한 서브 클래스의 접근 - 슈퍼 클래스의 private멤버, 슈퍼 클래스의 디폴트 멤버, 슈퍼 클래스의 public 멤버, 슈퍼 클래스의 projected 멤버

■ 서브 클래스/슈퍼 클래스의 생성자 호출과 실행 - 서브 클래스의 객체가 생성될 때(슈퍼 클래스 생성자와 서브 클래스 생성자 
                                            모두 실행)
    서브 클래스와 슈퍼 클래스의 생성자 선택 - 슈퍼 클래스와 서브 클래스(각각 여러 개의 생성자 작성 가능),
    서브 클래스의 객체가 생성될 떄(슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개가 실행), 
    서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정되는 방식(개발자의 명시적 선택, 컴파일러가 기본생성자 선택)

■ super() - 서브 클래스에서 명시적으로 슈퍼 클래스의 생섲아 선택 호출

■ 업캐스팅 - 서브 클래스의 래퍼런스를 슈퍼 클래스 래퍼런스에 대입, 슈퍼 클래스 래퍼런스로 서브 클래스 객체를 가리키게 되는 현상

■ 다운캐스팅 - 슈퍼 클래스 래퍼런스를 서브 클래스 래퍼런스에 대입, 업캐스팅된 것을 다시 원래대로 되돌리는 것, 반드시 명시적 타입 변환 지정 

■ 업캐스팅 래퍼런스로 객체 구별? - 업캐스팅된 래퍼런스로는 객체의 실제 타입을 구별하기 어려움 
instanceof 연산자 사용 - 래퍼런스가 가르키는 객체의 타입 식별



## 4월 5일
P.110
2차원 배열 선언 - ex)intArray[][]; 또는 int[][] intArray;

배열 리턴 - 배열의 래퍼런스만 리턴(배열 전체가 리턴되는 것이 아님)

메소드의 리턴 타입 - 리턴하는 배열 탑이과 리턴 받는 배열 타입 일치, 리턴 타입에 배열의 크기를 지정하지 않음

자바의 예외 처리 - 실행 중 오동작이나 결과에 악영향을 미치는 예상치 못한 상황 발생  
                try-catch-finally문 예외 처리 - 발생한 예외에 대한 개발자가 작성한 프로그램 코드에서 대응하는 것, try-catch-finally문 사용

P.132
자바의 객체 지향 특성 : 캡슐화
    캡슐화 : 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것

자바 상속 - 상위 클래스의 멤버를 하위 클래스가 물려받음

자바의 객체 지향 특성 : 다형성 
    다형성 - 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것

객체 지향 언어의 목적
    1. 소프트웨어의 생산성 향상
        -컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기 단축
        -객체 지향 언어
            소프트웨어 생산성 향상
            소프트웨어를 다시 만드는 부담 대폭 줄임

    2. 실세계에 대한 쉬운 모델링
        -초기 프로그래밍
        -현대 프로그래밍
        -객체 지향 언어

클래스  - 객체의 속성과 행위 선언
        - 객체의 설계도 혹은 틀    

틀 - 클래스의 틀로 찍어낸 실체

자바 클래스의 구성
    클래스  - class 키워드로 선언
            - 멤버 클래스 구성 요소
            - 클래스에 대한 public 접근 지정 : 다른 모든 클래스에서 클래스 사용 허락
            - 멤버에 대한 public 접근 지정 : 다른 모든 클래스에게 멤버 접근 허용  

생성자의 특징 - 생성자 이름은 클래스 이름과 동일
             - 생성자는 여러 개 작성 가능(생성자 중복)
             - 생성자는 객체 생성 시 한번만 호출
             -생성자의 목적은 객체 생성 시 초기화

this 요약  - this는 객체 자신에 대한 래퍼런스로서 메소드 안에서 사용된다.
           -this와 this()는 다르다. 
           2-this는 메소드에서 사용되며 현재 객체를 가르킨다.
           -static 메소드에선 사용이 불가하다.

P. 157
메소드 - 메소드는 c/c++의 함수와 동일
인자 전달 - 기본 타입의 값이 전달되는 경우 -> 호출자가 건네는 값이 메소드의 매개 변수에 복사되어 전달한다.
         - 객체가 전달되는 경우 -> 객체의 래퍼런스만 전달한다.
         - 배열이 전달되는 경우 -> 배열 래퍼런스만 매개 변수에 전달, 객체가 전달되는 경우와 동일

메소드 오버로딩 - 한 클래스 내에서 두 개 이상의 이름이 같은 메소드 작성

객체 치환 시 주의할 점 - 객체 지향은 객체 복사가 아니며, 래퍼런스의 복사이다.

객체 소멸 - new에 의해 할당 받은 객체와 배열 메모리를 자바 가상 기계로 되돌려 주는 행위
         - 소멸된 객체 공간은 가용 메모리에 포함

자바에서 사용자 임의로 객체 소멸 안됨 
    - 자바는 객체 소멸 연산자 없음
    - 객체 소멸은 자바 가상 기계의 고유한 역할
    -자바 개발자에게는 매우 다행스러운 기능

가비지 - 가르키는 래퍼런스가 하나도 없는 객체
가비지 컬렉션 - 자바 가상 기계의 가비지 컬렉터가 자동으로 가비지 수집, 변환
             - 자바 가상 기계가 가비지 자동 회수
             가비지 컬렉터에 의해 자동 수행
강제 가비지 컬렉션 강제 수행 - system 또는 rumntime객체의 gc() 메소드 호출하여 요청

P.167
패키지 - 상호 관련 있는 클래스 파일을 저장하여 관리하는 디렉터리
      - 자바 응용프로그램은 하나 이상의 패키지로 구성


## 3월 29일
P.55    
기본 타입 이외 리터럴 - null 리터럴, 문자열 리터럴(스트링 리터럴)
상수 선언 - final 키워드 사용, 선언 시 조깃값 지정, 실행 중 값 변경 불가

P.59
var키워드 - 타입을 생략하고 변수 선언 가능, 컴파일러가 추론하여 변수 타입 결정,
변수 선언 시 초깃값이 주어지지 않으면 컴파일 오류, var는 지역 변수 선언에만 한정

P.61
타입 변환 - 한 타입의 값을 다른 타입의 값으로 변환
자동 타입 변환 - 컴파일러의 의해 원래의 타입보다 큰 타입으로 자동 변환한다
강제 타입 변환 - 개발자의 의도적 타입 변환, ()안에 개발자가 명시적으로 타입 변환 지정
System.in - 키보드와 직접 연결되는 표준 입력 스트림 객체
scanner 클래스 - 읽은 바이트를 문자 정수 실수 문자열 등 다양한 타입으로 변환하여 리턴
    int nextInt(), string next() 자주 씀


P.66
식과 연산자
    연산자 - 주어진 식을 계산하여 결과를 얻어내는 과정
    증감 연산 - 1 증가 혹은 감소 시키는 연산
    대입 연산 - 연산의 오른쪽 결과는 왼쪽 변수에 대입
    비교 연산 - 두 개의 값을 비교하여 true/false 결과
    논리 연산 - 두 개의 논리 값에 논리 연산 논리 결과
    조건 연산 - 1개의 피연산자로 구성된 상항 연산자
    비트 연산 - 비트 논리 연산(비트끼리 AND,OR,XOR,NOT 연산), 비트 시프트 연산
    비트 논리 연산 - 피연산자의 각 비트들을 대상으로 하는 연산


P.78
조건문
중첩 if-else문
switch문 - 식과 case문의 값과 비교해서 일치하면 해당 case의 실행문장을 수행(break문을 만나면 switch문을 벗어남)
                                     일치하는 것이 없으면 default 문 실행(default문은 생략 가능)
case 문의 값 - (문자,정수,문자열 리터럴)만 허용, 실수 리터럴은 허용되지 않은


P.92
반복문 - 자바 반복문(for문, while문, do while문) for문을 가장 많이 사용함
while문 - 조건식이 참인 동안 반복 실행
continue문
break문

P.101
배열 - 인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료 구조
배열 선언 - 배열의 이름 선언
배열 생성 - 배열 공간 할당 받는 과정
배열 초기화 - 배열 생성과 값 초기화
배열 인덱스 - 배열의 인덱스는 0 ~ (배열크기 -1)  
자바의 배열은 객체로 처리 - 배열 객체의 lengh 필드





## 3월 22일
ctrl + shift + p --> java p --> create java project
루트에 있던 Hello를 src로 이동함

P.25 자바의 플랫폼 독립성, WORA - 한번 작성되고 컴파일된 자바 코드는 운영체제나 CPU 등 플랫폼에 상관없이 JVM만 있으면 어떤 컴퓨터에서든 동일하게 실행되는데 이것을 WORA라고 함

P.27 자바와 타 언어(C/C++)의 실행 차이 - C/C++은 같이 컴파일한 목적 파일을 링크시켜 하나의 실행파일을 만들며 
 실행파일 하나만 잇으면 실행이 가능함. 그러나 자바는 링크 과정이 없으며 자바 가상 기계가 컴파일된 클래스 파일을 실행함

P.28 JDK와 JRE - JDK는 자바 컴파일러 등의 개발 도구와 JRE로 구성됨. 우리는 javac를 많이 사용함. 
 자바 패키지 - 서로 관련된 클래스들을 분류하여 묶어 놓은 것, 계층구조로 되어 있음(클래스의 이름에 패키지 이름도 포함).
    
P.35 자바 통합 개발 환경, 이클립스 - IDE란? 통합 개발 환경, 편집, 컴파일, 디버깅을 한번에 할 수 잇는 통합된 개발 환경
    이클립스 - 자바 응용 프로그램 개발을 위한 통합 개발 환경, IBM에 의해 개발된 오픈 프로젝트
                                  



P.41 자바 응용의 종류 : 서블릿 응용프로그램 - 서블릿은 웹 서버에서 실행되는 서버용 자바 프로그램임
 EX)쇼핑몰이나 온라인 뱅킹 등등 구현

P.43 자바의 특성(1) - 플랫폼 독립성, 객체지향, 클래스로 캡슐화( 자바의 모든 변수나 함수는 클래스 내에 선언, 클래스    
 안에서 클래스(내부클래스) 작성 가능 ), 소스와 클래스 파일(하나의 소스 파일에 여러 클래스를 작성 가능)

P.45 자바의 특성(2) - 실행 코드 배포, 패키지, 멀티스레드, 가비지 컬렉션(사용하지 않는 메모리를 쓰레기통에 버림)

자바의 특성(3) - 실시간 응용프로그램에 부적합, 자바 프로그램은 안전, 프로그램 작성 쉬움, 실행 속도 개선을 위한 JIT 
 컴파일러 사용

2장 
2-1 설명
식별자란? - 클래스, 변수, 상수, 메소드 등에 붙이는 이름, 식별자의 원칙, 
대소문자 구별 - int barChart; 와 int barchart;는 서로 다른 식별자 선언
자바의 데이터 타입 - 기본타입 8개, 래퍼런스 타입 1개이며
문자열 - 문자열은 기본 타입이 아님, String클래스로 문자열 표현

변수와 선언
 변수 - 프로그램 실행 중에 값을 임시 저장하기 위한공간
 변수 선언 - 데이터 타입에서 정한 크기의 메모리 할당

리터럴과 정수 리터럴
 리터럴 - 프로그램에서 직접 표현한 값, 정수 실수 문자 논리 문자열 리터럴 있음
 정수 리터럴 - 10진수, 8진수, 16진수, 2진수 리터럴
 정수 리터럴은 int형으로 컴파일 

## 3월 15일
메세지를 안 쓰면 커밋이 안됨
커밋 메세지엔 영문으로 쓰는 게 좋고 한 일을 쓰면 됨 
ex - 강의 내용 정리

## 명령어 모음  
git config user.name "zkgh5"

git config user.email "rose55229@naver.com"

git config suerd.name

Create readme file
