# 김준호 202330208  
## 스페이스바 2번 줄 넘김  
## 파일 입출력(13장) 필수 <10장 11장 14장 제외>  
## 입출력(13장) 먼저 하고 스레드(12장)하고 스윙 컴포넌트(10장)에서 몇 개만  


## 6월 7일  
11장  
■ 스윙의 페인팅 기본  
    - 모든 컴포넌트는 자신의 모양을 스스로 그린다  
    - 컨테이는 자신을 그린 후 그 위에 자식 컴포넌트들에게 그리기 지시  
    - 모든 스윙 컴포넌트는 자신의 모양을 그리는 paintComponent() 메소드 보유  

■ public void paintComponent(Graphics g)  
    - 스윙 컴포넌트가 자신의 모양을 그리는 메소드  

    - JComponent의 메소드 - 모든 스윙 컴포넌트가 이 메소드를 오버라이딩 함  

    ● 언제 호출되는가?  
        - 컴포넌트가 그려져야 하는 시점마다 호출  
        - 크기나 위치가 변경되거나 컴포넌트가 가려졌던 것이 사라지는 등  

    ● 매개변수인 Graphics 객체  
        - 그래픽 컨텍스트 :  컴포넌트 그리기에 필요한 도구를 제공하는 객체  
        - 자바 플랫폼에 의해 공급  
        - 색 지정, 도형 그리기, 이미지 그리기 드으이 메소드 제공  

■ 그래픽 기반 GUI 프로그래밍  
    - 스윙 컴포넌트에 의존하지 않고 선, 원 이미지 등을 이용하여 직접 화면을 구성하는 방법  
    
    ● 그래픽 기반 GUI 프로그래밍의 학습이 필요한 이유  
        - 컴포넌트의 한계를 극복하고 차트, 게임 등자유로운 컨텐트 표현  
        - 그래픽은 컴포넌트에 비해 화면 출력 속도가 빠름  
        - 스윙 컴포넌트들로 모두 그래픽으로 작성되어 있어, 그래피겡 대한 학습 은 자바 GUI의 바탕 기술을 이해하는데 도움  
        - 그래픽을 이용하여 개발자 자신만의 컴포넌트 개발  

■ 그래픽과 색의 폰트  
    - 자바의 색 : red, green, blue 성분으로 구성, 각 성분은 0~255(8비트) 범위의 정수  
        (예시 : 빨간색=new Color(255, 0, 0) 초록색=new Color(0x0000ff00), 노란색=Color.YELLOW)  

    - 폰트 : Font 클래스  

    ● Graphics에 색과 폰트 설정  
        - void setColor(Color color) // 그래픽 색을 color로 설정, 그리기 시에 색으로 이용  
        - void setFont(Font font) // 그래픽 폰트를 font로 설정, 문자열 출력 시 폰트로 이용  

        Ex - Grapics g;  
             Font f = new Font("Arial", FontITALIC, 30);  
             g.setFont(f);  
             g. setColor(Color);  
             ~~~~~~~~~  

■ 스윙에서 이미지를 그리는 2가지 방법
    ● JLabel을 이용한 이미지 그리기
        - 장점 : 이미지 그리기 간편 용이
        - 단점 : 이미지의 원본 크기대로 그리므로 이미지 크기 조절 불가

    ● Graphics의 drawImage()로 이미지 출력
        - 장점 : 이미지 일부분 등 이미지의 원본 크기와 다르게 그리기 가능
        - 단점 : 컴포넌트로 관리할 수 없음, 이미지의 위치나 크기 등을 적절히 조절하는 코딩 필요     

■ repaint()  
    - 모든 컴포넌트가 가지고 있는 메소드  

    - 자바 플랫폼에게 컴포넌트 그리기를 강제 지시하는 메소드
    
    ● repaint()를 호출하면, 자바 플랫폼이 컴포넌트의 paintComponent()호출  
        - repaint()의 호출이 필요한 경우  
            - 프로그램에서 컴포넌트의 모양과 위치를 변경하고 바로 화면에 반영시키고자 하는 경우  
            - 컴포넌트가 다시 그려져야 그 때 변경된 위치에 변경된 모양으로 출력됨   
            - repaint()는 자바 플랫폼에게 지금 당장 컴포넌트를 다시 그리도록 지시함  
        - 부모 컴포넌부터 다시 그리는 것이 좋음  
            - 컴포넌트 repaint()가 불려지면  
                - 이 컴포넌트는 새로운 위치에 다시 그려지지만 이전의 위치에 있던 자신의 모영이 남아있음  

            - 부모 컴포넌트의 repaint()를 호출하면  
                - 부모 컨테이너의 모든 내용을 지우고 자식을 다시 그리기 때문에 컴포넌트의 이전 모양이 지워지고  
                  새로 변경된 크기나 위치에 그려짐  

12장  
■ 스레드와 운영체제  
    ● 스레드  
        - 운영체제에 의해 관리되는 하나의 작업 혹은 태스크  
        - 스레드와 태스크(혹은 작업) 은 바꾸어 사용해도 무관  

    ● 스레드 구성  
        - 스레드 코드  
            - 작업을 실행하기 위해 작성한 프로그램 코드  
            - 개발자가 작성  

        - 스레드 정보  
            - 스레드 명, 스레드 ID, 스레드 소요시간, 스레드 우선 순위등 운영체제가 관리하는 정보          

■ 멀티태스킹 구현 기술  
    ● 멀티프로세싱  
        - 하나의 응용프로그램이 여러 개의 프로세스를 생성하고, 각 프로세스가 하나의 작업을 처리하는 기업  
        - 각 프로세스 독립된 메모리 영역을 보유하고 실행  
        - 프로세스 사이의 문맥 교환에 따른 과도한 오버헤드와 시간 소모의 문제점  

    ● 멀티스레딩  
        - 하나의 응용프로그램이 여러 개의 스레드를 생성하고, 각 스레드가 하나의 작업을 처리하는 기업  
        - 하나의 응용프고름에 속한 스레드는 변수 메모리, 파일 오픈 테이블 등 자원으로 공유하므로,  
          문맥 교환에 따른 오버헤드가 매주 작음  
        - 현재 대부분의 운영체제가 멀티스레딩을 기본으로 하고 있음  

■ 자바 스레드와 JVM  
    ● 자바 스레드  
        - 자바 가상 기계에 의해 스케쥴되는 실행 단위의 코드 블럭  
        - 스레드의 생명 주기는 JVM에 의해 관리됨 : JVM은 스레드 단위로 스케쥴링  

    ● JVM과 자바의 멀티스레딩   
        - 하나의 JVM은 하나의 자바 응용프로그램만 실행  
            - 자바 응용프로그램이 시작될 때 JVM이 함께 실행됨  
            - 자바 응용프로그램이 종료하면 JVM도 함께 종료함  
        
        - 응용프로그램은 하나 이상의 스레드로 구성 가능  

■ 자바 스레드 만들기  
    ● 스레드 만드는 2가지 방법  
        - java.lang.Thread 클래스를 상속받아 스레드 작성  
        - java.lang.Runnable 인터페이스를 구현하여 스레드 작성  

■ Thread 클래스를 상속받아 스레드 만들기  
    - Thread를 상속받아 run() 오버라이딩   

    ● run() 메소드 작성  
        - run() 메소드를 스레드 코드라고 부름  
        - run() 메소드에서 스레드 실행 시작  

    ● 스레드 객체 생성  
        - 생성된 객체는 필드와 메소드를 가진 객체일 뿐 스레드로 작동하지 않음  

    ● 스레드 시작  
        ● start() 메소드 호출  
            - 스레드로 작동 시작  
            - 스레드 객체의 run()이 비로소 실행  
            - JVM에 의해 스케쥴되기 시작함   
 
■ Synchronized 블록 지정  
    ● synchronized 키워드  
        - 스레드가 독점적으로 실행해야 하는 부분(동기화 코드)을 표시하는 키워드  
            - 임계 영역 표기 키워드  

    ● synchronized 블록이 실행될 때  
        - 먼저 실행한 스레드가 모니터 소유  
            - 모니터란 해당 객체를 독점적으로 사용할 수 있는 권한  

        - 모니터를 소유한 스레드가 모니터를 내놓을 때까지 다른 스레드 대기    

■ wait()-notify()를 이용한 스레드 동기화  
    ● wait()-notify()가 필요한 경우   
        - 공유 데이터로 두 개 이상의 스레드가 데이터를 주고 받을 때  
            - producer-consumer문제  

    ● 동기화 메소드  
        - wait() : 다른 스레드가 notify()를 불러줄 때까지 기다린다  
        - notify() : wait()를 호출하여 대기중인 스레드를 깨운다   
            - wait(), notify()는 Object의 메소드          



## 5월 31일  
10장  
■ JComponent  
    - 스윙 컴포넌트는 모두 상속받는 슈퍼 클래스, 추상 클래스  
    - 스윙 컴포넌트들이 상속받는 공통 메소드의 상수 구현  

■ 문자 레이블 생성  
    - JLabel textLabel = new JLabel("사랑합니다);  

  이미지 레이블 생성  
    - 이미지 파일로부터 이미지를 읽기 위해 Imagelcon 클래요 사용  
    - 다룰 수 있는 이미지 : png, gif, jpg  

  수평 정렬 값을 가진 레이블 컴포넌트 생성  
    - 수평 정렬로, 문자열과 이미지를 모두 가진 테이블  

■ JCheckBox의 용도  
    - 선택과 비선택 두 상태만 가지는 버튼

■ Item 이벤트  
    - 체크 박스의 선택 상태에 변화가 생길 때 발생하는 이벤트  
    - 이벤트가 발생하면 ItemEvent 객체 생성  
    - ItemListener 리스너를 이용하여 이벤트 처리  

■ JRadioButton의 용도  
    - 버튼 그룹을 형성하고 그룹에 속한 버튼 중 하나만 선택되는 라디오버튼  
    - 체크박스와의 차이점 : 체크 박스는 각각 선택.해제가 가능하지만 라디오버튼은 그룹에 속한 버튼 중 하나만 선택  

■ JtextField  
    ● 한 줄의 문자열을 입력 받는 창(텍스트 필드)  
        - 텍스트 입력 도중 <Enter>키가 입력되면 Action 이벤트 발생  
        - 입력 가능한 문자 개수와 입력 창의 크기는 서로 다름  

■ JList<E>  
    - 하나 이상의 아이템을 보여주고 아이템을 선택하도록 하는 리스트  
    - java 7부터 제네릭 리스트로 바뀜  
    - JScript에 JList<E>를 삽입하여 스크롤 가능  

■ 메뉴 만들기에 필요한 스윙 컴포넌트  
    ● 메뉴아이템 - JMenuItem  
      메뉴 - JMenu(여러 개의 메뉴 아이템을 가짐)  
      메뉴바 - JMenuBar(여러 개의 메뉴를 붙이는 바이며, 프레임에 부착됨)  
      분리선 - 메뉴아이템 사이의 분리선으로 separator라고 부름, JMenu의 addSeparator()를 호출하여 삽입함  

■ 팝업 다이얼로그  
    - 사용자에게 메세지를 전달하거나 문자열을 간단히 입력받는 용도  
    - JOptionPane클래스를 이용하여 생성  

■ 확인 다이얼로그  
    - JOptionPane.showConfirmDialog()  
    - 사용자로부터 Yes/No 응답을 입력 받는 다이얼로그  


## 5월 24일  
■ 이벤트 기반 프로그래밍  
    - 이벤트의 발생에 의해 프로그램 흐름이 결정되는 방식  
    - 반대되는 개념 : 배치 실행  
    - 이벤트 기간 응용 프로그램의 구조 : 각 이벤트마다 처리하는 리스너 코드 보유  
    
    ● 이벤트 종류  
        - 사용자의 입력 : 마우스 드래그, 마우스 클릭, 키보드 누름  
        - 센서로부터의 입력, 네트워크로부터 데이터 송수신  
        - 다른 응용프로그램이나 다른 스레드로부터의 메세지  

    ● 이벤트가 처리되는 과정 
        1. 이벤트 발생(예 : 마우스의 움직임 혹은 키보드 입력)  
        2. 이벤트 객체 생성  
        3. 응용프로그램에 작성된 이벤트 리스너 찾기  
        4. 이벤트 리스너 실행  

■ 이벤트 객체  
    - 발생한 이벤트에 관한 정보를 가진 객체  
    - 이벤트 리스너에 전달됨    

    ● 이벤트 객체가 포함하는 정보  
        - 이벤트 종류와 이벤트 소스  
        - 이벤트가 발생한 화면 좌표 및 컴포넌트 내 좌표  
        - 이벤트가 발생한 버튼이나 메뉴 아이템의 문자열  
        - 출력된 마우스 버튼 번호 및 마우스의 클릭 횟수  
        - 키의 코드 값과 문자 값  
        - 체크박스 라디오버튼 등과 같은 컴포넌트에 이벤트가 발생했다면 체크 상태  

    ● 이벤트 소스를 알아 내는 메소드  
        - Object getSource()  

■ 리스너 인터페이스  
    - 이벤트 리스너 : 이벤트를 처리하는 자바 프로그램 코드, 클래스로 작성  
    - 자바는 다양한 리스너 인터페이스 제공(예 : ActionListener 인터페이스 - 버튼 클릭 이벤트를 처리함)  

■ 이벤트 리스너 작성 과정 사례  
    1. 이벤트와 이벤트 리스너 선택(버튼 클릭을 처리하고자 하는 경우)  
    2. 이벤트 리스너 클래스 작성 : ActionListener 인터페이스 구현  
    3. 이벤트 리스너 등록(이벤트를 받아 처리하고자 하는 컴포넌트에 이벤트 리스너 등록)  
 
■ 이벤트 리스너 작성 방법  
    ● 3가지 방법  
        - 독립 클래스로 작성(이벤트 리스너를 완전한 클래스로 작성)  
        - 내부 클래스로 작성(클래스 안에 멤버처럼 클래스 작성)  
        - 익명 클래스로 작성(클래스의 이름 없이 간단히 리스너 작성)  

■ 익명 클래스로 이벤트 리스너 작성  
    - 익명 클래스 : 이름 없는 클래스  
    - 간단한 리스너의 경우 익명 클래스 사용 추천  

■ 어댑터 클래스  
    ● 이벤트 리스너 구현에 따른 부담  
        - 리스너의 추상 메소드를 모두 구현해야 하는 부담  
        - 예시 : 마우스 리스너에서 마우스가 눌러지는 경우(mousePressed())만 처리하고자 하는 경우에도
                나머지 4개의 메소드를 모두 구현해야 하는 부담  
    - 어댑트 클래스 : 리스너의 모든 메소드를 단순 리턴하도록 만든 클래스  

■ Key 이벤트와 포커스  
    - 키 입력시 다음 세 경우 각각 Key 이벤트 발생  
    ● 키 이벤트를 받을 수 있는 조건  
        - 모든 컴포넌트  
        - 현재 포커스를 가진 컴포넌트가 키 이벤트 독점  
    ● 포커스  
        - 컴포넌트나 응용프로그램이 키 이벤트를 독점하는 권한  
        - 컴포넌트에 포커스 설정 방법 : 다음 2 라인 코드 필요  

■ 유니코드 키의 특징  
    - 국제 산업 표준  
    - 전 세계의 문자를 컴퓨터에서 일관되게 표현하기 위한 코드 체계  
    - 문자들에 대해서만 키 코트 값 정의  
    - 문자가 아닌 키 경우에는 표준화된 키 코드 값 없음  
    - 유니코드 키가 입력되는 경우 : keyPressed(), ketTyped(), keyReleased()가 순서대로 호출    

■ 가상 키와 입력된 키 판별  
    ● KeyEvent 객체  
        - 입력된 키 정보를 가진 이벤트 객체  
        - KeyEvent 객체의 메소드로 입력된 키 판별  

    ● KeyEvent 객체의 메소드로 입력된 키 판별  
        ▲ char KeyEvent.getKeyChar() 
            - 키와 유니코드 문자 값 리턴   
            - Unicode 문자 키인 경우에만 의미 있음  
            - 입력된 키를 판별하기 위해 문자 값과 비교하면 됨  
    
    ● int KeyEvent.getKeyCode()  
        - 유니코드 키 포함  
        - 모든 키에 대한 정수형 키 코드 리턴  
        - 입력된 키를 판별하기 위해 가상키 값과 비교하여야 함  
        - 가상 키 값은 KeyEvent 클래스에 상수로 선언  

■ 마우스 리스너 달기와 MouseEvent 객체 활용  
    - 마우스 리스너 달기  
    ▲ MouseEvent 객체 활용  
        - 마우스 포인터의 위치, 컴포넌트 내 상대 위치  


## 5월 17일
■ 컨테이너 배치관리자    
    - 컨테이너마다 하나의 배치관리자 존재  
    - 컨테이너에 부착되는 컴포넌트의 위치와 크기 결정  
    - 컨테이너의 크기가 변경되면, 컴포넌트의 위치와 크기 재결정  
 
■ 배치 관리자 대표 유형 4가지  
    - FlowLayout 배치관리자  
    - BorderLayout 배치관리자  
    - GridLayout 배치관리자  
    - CardLayout 배치관리자  

■ 컨테이너의 디폴트 배치관리자 - 컨테이너 생성시 자동으로 생성되는 배치관리자  

■ 컨테이너에 새로운 배치관리자 설정 - setLayout(LayoutManager lm) 메소드 호출(lm을 새로운 배치관리자로 설정)  

■ 생성자 - FlowLayout()  
        - FlowLayout(int align, int hGap, int yGap)  
        - align : 컴포넌트를 정렬하는 방법 지정.왼쪽 정렬(FlowLayout.LEFT), 오른쪽 정렬(FlowLayout.RIGHT), 
        중앙 정렬(FlowLayout.CENTER(디폴트))  
        - hGap : 좌우 두 컴포넌트 사이의 수평 간격. 픽셀 단위. 디폴트는 5  
        - yGap : 상하 두 컴포넌트 사이의 수직 간격. 픽셀 단위. 디폴트는 5  

■ borderLayout 배치관리자   
    - 배치방법 : 컨테이너 공간을 5 구역으로 분할, 배치(동, 서, 남, 북, 중앙)  

■ GridLayout 배치관리자  
    - 배치방법 : 컨테이너 공간을 동일한 사각형 격자(그리드)로 분할하고 각 셀에 컴포넌트 하나씩 매치  

■ GridLayout 생성자
    - GridLayout()  
    - GridLayout(int rows, int cols)  

■ 컴포넌트의 절대 위치와 크기 설정   
    - 배치 관리자가 없는 컨테이너의 삽입은 컴포넌트의 크기와 위치를 직접 설정해야함  



## 5월 3일
■ 컬렉션 
    -요소라고 불리는 가변 개수의 객체들의 저장소, 
    -고정 크기의 배열을 다루는 어려움 해소, 
    -다양한 객체들의 삽입, 삭제, 등의 관리 용이  

■ 컬렉션은 "제너릭" 기법으로 구현    
    ●제너릭 - 특정 타임만 다루지 않고, 여러 종류의 타입으로 변실할 수 있도록 클래스나 메소드를 일반화시키는 기법  
           - JDK 1.5부터 도입  
           - C++의 템플릿과 동일  
    
    ●제너릭 컬렉션 사례 : 벡터 Vector<E>  
        -정수만 다루는 컬렉션 벡터 Vector<Integer>  
        -문자열만 다루는 컬렉션 벡터 Vector<String>       

■ 컬렉션의 요소는 객체만 가능
    -int, char, double등의 기본 타입으로 구체화 불가  

■ Vector<E>의 특성
    - <E>에 사용할 요소의 특정 타입으로 구체화  
    - 배열을 가변 크기로 다룰 수 있게 하는 컨테이너  
    - 요소 객체들을 삽입, 삭제, 검색하는 컨테이너  
    - Vector의 삽입 가능한 것 => 객체, null, 기본 타입의 값은 Wrapper객체로 만들어 저장 
    - Vector의 객체 삽입 => 벡터의 맨 뒤, 중간에 객체 삽입 가능  
    - Vector의 객체 삭제 => 임의의 위치에 있는 객체 삭제 가능  

■ 컬렉션과 자동 박싱/언박싱 
    - 1.5 이전 : 기본 타입 데이터를 Wrapper 객체로 만들어 삽입      
    - 1.5 이후 : 자동 박싱/언박싱이 작동하여 기본 타입 값 삽입 가능  

■ ArrayList<E> 
    - 가변 크기 배열을 구현한 클래스
    - 벡터와 거의 동일 

■ 컬렉션의 순차 검색을 위한 Iterator
    - Iterator<E> 인터페이스 => 리스트 구조의 컬렉션에서 요소의 순차 검색을 위한 인터페이스
    - Iterator 객체 얻어내기 => 컬렉션의 iterator() 메소드 호출

■ HashMap<K,V>
    ● 키(key)와 값(value)의 쌍으로 구성되는 요소를 다루는 컬렉션
        - 키와 값이 한 쌍으로 삽입
        - '값'을 검색하기 위해서는 반드시 '키' 이용

    ● 삽입 및 검색이 빠른 특징 
        - 요소 삽입 : put() 메소드
        - 요소 검색 : get() 메소드

■ 자바의 GUI
    ● GUI 
        - 사용자가 관리하게 입출력 할 수 있도록 그래픽으로 화면을 구성하고, 마우스나 키보드로 입력 받을 수 있도록
            지원하는 사용자 인터페이스 

    ● 자바 언어에서 GUI 응용프로그램 작성
        - AWT와 Swing 패키지에 강력한 GUI 컴포넌트 제공
        - 쉬운 GUI 프로그래밍

    ◆ AWT와 Swing 패키지
        ● AWT 패키지 - 자바가 처음 나왔을 때부터 배포된 GUI 패키지, 최근에는 거의 사용하지 않음
                   - AWT 컴포넌트는 중량 컴포넌트
 
        ● Swing 패키지 - AWT 기술을 기반으로 작성된 자바 라이브러리
                       - 모든 AWT 기능 + 추가된 풍부하고 화려한 고급 컴포넌트 

■ 컨테이너
    - 다른 컴포넌트를 포함할 수 있는 GUI 컴포넌트
    - 다른 컨테이너에 포함될 수 있음

■ 컴포넌트 
    - 컨테이너에 포함되어야 화면에 출력될 수 있는 GUI 객체
    - 다른 컴포넌트를 포함할 수 없는 순수 컴포넌트    

■ 최상위 컨테이너
    - 다른 컨테이너에 포함되지 않고도 화면에 출력되며 독립적으로 존재 가능한 컨테이너

■ 스윙 GUI 프로그램을 만드는 과정
    1. 스윙 프레임 만들기
    2. main() 메소드 작성
    3. 스윙 프레임에 스윙 컴포넌트 붙이기

■ 스윙 프레임 
    - 모든 스윙 컴포넌트를 담는 최상위 컨테이너
    - JFrame을 상속받아 구현
    - 프레임의 크기 반드시 지정 : setSize() 호출





## 4월 19일
■ 메소드 오버라이딩 - 서브 클래스에서 슈퍼 클래스에 선언된 메소드를 중복 작성하여 슈퍼 클래스에 작성된 메소드를 무력화 시키고 객체의 주인노릇을 함  

■ 목적 - 오버라이딩으로 다형성 실현, 하나의 인터페이스에도 서로 다른 구현  
■ 동적 바인딩 - 오버라이딩된 메소드 호출  
■ super키워드로 슈퍼 클래스의 멤버 접근  

■ 추상 메소드 - abstract로 선언한 메소드의 코드는 없고 원형만 선언  
■ 추상 클래스 - 추상 메소드를 가지며, abstract로 선언된 클래스, 추상 메소드 없이 abstract로 선언한 클래스  
■ 추상 클래스는 온전한 클래스가 아니기 때문에 인스턴스를 생성할 수 없음  
■ 추상 클래스 상속 - 추상 클래스를 상속받으면 추상 클래스가 됨, 서브 클래스도 abstract로 선언해야 함  
■ 추상 클래스 구현 - 서브 클래스에서 슈퍼 클래스의 추상 메소드 구현, 추상 클래스를 구현한 서브 클래스는 추상 클래스 아님  
■ 추상 클래스의 목적 - 상속을 위한 슈퍼 클래스로 활용하는 것, 서브 클래스에서 추상 메소드 구현, 다형성 실현  

■ 자바의 인터페이스 - 클래스가 구현해야 할 메소드들이 선언되는 추상형   
■ 인터페이스 선언 - interface 키워드로 선언   
■ 자바 인터페이스에 대한 변화 - 여전히 인터페이스에는 필드(멤버 변수) 선언 불가  
■ 자바 인터페이스 특징 - 인터페이스의 객체 생성 불가  
■ 인터페이스 상속 - 인터페이스 간에 상속 가능, 인터페이스 다중 상속 허용  

■ 자바의 패키지와 모듈 - 
    패키지 - 하나의 응용프로그램은 한 개 이상의 패키지로 작성, 서로 관련된 클래스와 인터페이스를 컴파일한 클래스 파일들을 묶어 놓은 디렉토리  

    모듈 - 여러 패키지와 이미지 등의 자원을 모아 놓은 컨테이너, 하나의 모듈을 하나의 .jmod 파일에 저장  

■ 모듈화의 목적 - java9부터 자바 api를 여러 모듈로 분할  
■ 모듈의 현실 - 복잡한 개념, 큰 자바 응용 프로그램에는 개발, 유지보수 등에 적합, 현실적으로 모듈로 나누어 자바           
    프로그램을 작성할 필요 없음   

■ 패키지 만들기 - 클래스 파일이 저장되는 위치는 클래스나 인터페이스가 컴파일되면 클래스 파일 생성, 클래스 파일은       
                패키지로 선언된 디렉토리에 저장  

■ 패키지 선언 - 소스 파일의 맨 앞에 컴파일 후 저장될 패키지 지정  
■ 모듈 개념 - 패키지와 이미지 등의 리소스를 담은 컨테이너  
■ 모듈화의 목적 - 큰 컴포넌트들을 필요에 따라 조립하여 사용하기 위함  

■ object 클래스 특징 - 모든 자바 클래스는 반드시 object를 상속 받도록 자동 컴파일, 모든 클래스의 슈퍼 클래스  
■ 객체 속성 - object 클래스는 객체의 속성을 나타내는 메소드 제공  

■ 객체 비교(==)와 equal()메소드  
    ==연산자 - 객체 래퍼런스 비교  
    boolean equals(Object obj) - 두 객체의 내용을 비교  

■ Wrapper클래스 - 자바의 기본 타입을 클래스화한 8개 클래스를 통칭  
    용도 - 객체만 사용할 수 있는 컬렉션 등에 기본 타입의 값을 사용하기 위해->Wrapper 객체로 만들어 사용  

■ 박싱 - 기본 타입의 값을 Wrapper 객체로 변환하는 것  
■ 언박싱 - Wrapper 객체에 들어 있는 기본 타입의 값을 빼내는 것  
■ 스트링 리터럴 - 자바 가상 기계 내부에서 리터럴 테이블에 저장되고 관리함  



## 4월 12일
■ 자바의 접근 지정자 - private public protected 디폴트(접근 지정자 생략)  
■ 접근 지정자의 목적 - 클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용  
■ 클래스 접근지정 - 다른 클래스에서 사용하도록 허용할 지 지정  
               - public 클래스  
               - 디폴트 클래스(접근지정자 생략)  

■ public 멤버 - 패키지에 관계 없이 모든 클래스에게 접근 허용  

■ pirvate 멤버 - 동일 클래스 내에만 접근 허용, 상속 받은 서브 클래스에서 접근 불가  

■ protected 멤버 - 같은 패키지 내의 다른 모든 클래스에게 접근 허용, 상속 받은 서브 클래스는 다른 패키지에 있어도 접근 가능  

■ 디폴트 멤버 - 같은 패키지 내의 다른 클래스에게 접근 허용  

■ static 멤버 - static 멤버는 클래스당 하나만 생성, 객체들에 의해 공유됨  
■ static 멤버 사용 - 클래스 이름으로 접근 가능, 객체의 멤버로 접근 가능 non static 멤버는 클래스 이름으로 접근 안됨  

■ final 필드 - final 필드 실수 선언(상수를 선언할 때 사용, 상수 필드는 선언 시에 초기 값을 지정하여야 한다, 실행 중에 값을 바꿀 수 없다)  

P.191  
■ 상속 선언 - extends 키워드로 선언, 부모 클래스 -> 슈퍼 클래스, 자식 클래스 -> 서브 클래스  
■ 자바 상속의 특징 - 클래스 다중 상속 불허, 모든 자바 클래스는 묵시적으로 object클래스 상속 받음  
■ 슈퍼 클래스의 멤버에 대한 서브 클래스의 접근 - 슈퍼 클래스의 private멤버, 슈퍼 클래스의 디폴트 멤버, 슈퍼 클래스의 public 멤버, 슈퍼 클래스의 projected 멤버  

■ 서브 클래스/슈퍼 클래스의 생성자 호출과 실행 - 서브 클래스의 객체가 생성될 때(슈퍼 클래스 생성자와 서브 클래스 생성자 
                                            모두 실행)  
    서브 클래스와 슈퍼 클래스의 생성자 선택 - 슈퍼 클래스와 서브 클래스(각각 여러 개의 생성자 작성 가능),  
    서브 클래스의 객체가 생성될 떄(슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개가 실행),  
    서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정되는 방식(개발자의 명시적 선택, 컴파일러가 기본생성자 선택)  

■ super() - 서브 클래스에서 명시적으로 슈퍼 클래스의 생섲아 선택 호출  

■ 업캐스팅 - 서브 클래스의 래퍼런스를 슈퍼 클래스 래퍼런스에 대입, 슈퍼 클래스 래퍼런스로 서브 클래스 객체를 가리키게 되는 현상  

■ 다운캐스팅 - 슈퍼 클래스 래퍼런스를 서브 클래스 래퍼런스에 대입, 업캐스팅된 것을 다시 원래대로 되돌리는 것, 반드시 명시적 타입 변환 지정  

■ 업캐스팅 래퍼런스로 객체 구별? - 업캐스팅된 래퍼런스로는 객체의 실제 타입을 구별하기 어려움  
instanceof 연산자 사용 - 래퍼런스가 가르키는 객체의 타입 식별  



## 4월 5일
P.110
2차원 배열 선언 - ex)intArray[][]; 또는 int[][] intArray;

배열 리턴 - 배열의 래퍼런스만 리턴(배열 전체가 리턴되는 것이 아님)  

메소드의 리턴 타입 - 리턴하는 배열 탑이과 리턴 받는 배열 타입 일치, 리턴 타입에 배열의 크기를 지정하지 않음  

자바의 예외 처리 - 실행 중 오동작이나 결과에 악영향을 미치는 예상치 못한 상황 발생   
                try-catch-finally문 예외 처리 - 발생한 예외에 대한 개발자가 작성한 프로그램 코드에서 대응하는 것, try-catch-finally문 사용  

P.132  
자바의 객체 지향 특성 : 캡슐화  
    캡슐화 : 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것  

자바 상속 - 상위 클래스의 멤버를 하위 클래스가 물려받음  

자바의 객체 지향 특성 : 다형성  
    다형성 - 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것  

객체 지향 언어의 목적  
    1. 소프트웨어의 생산성 향상  
        -컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기 단축  
        -객체 지향 언어  
            소프트웨어 생산성 향상  
            소프트웨어를 다시 만드는 부담 대폭 줄임  

    2. 실세계에 대한 쉬운 모델링  
        -초기 프로그래밍  
        -현대 프로그래밍  
        -객체 지향 언어  

클래스  - 객체의 속성과 행위 선언  
        - 객체의 설계도 혹은 틀     

틀 - 클래스의 틀로 찍어낸 실체  

자바 클래스의 구성  
    클래스  - class 키워드로 선언  
            - 멤버 클래스 구성 요소  
            - 클래스에 대한 public 접근 지정 : 다른 모든 클래스에서 클래스 사용 허락  
            - 멤버에 대한 public 접근 지정 : 다른 모든 클래스에게 멤버 접근 허용  

생성자의 특징 - 생성자 이름은 클래스 이름과 동일  
             - 생성자는 여러 개 작성 가능(생성자 중복)  
             - 생성자는 객체 생성 시 한번만 호출  
             -생성자의 목적은 객체 생성 시 초기화  

this 요약  - this는 객체 자신에 대한 래퍼런스로서 메소드 안에서 사용된다.  
           -this와 this()는 다르다. 
           2-this는 메소드에서 사용되며 현재 객체를 가르킨다.  
           -static 메소드에선 사용이 불가하다.  

P. 157
메소드 - 메소드는 c/c++의 함수와 동일  
인자 전달 - 기본 타입의 값이 전달되는 경우 -> 호출자가 건네는 값이 메소드의 매개 변수에 복사되어 전달한다.  
         - 객체가 전달되는 경우 -> 객체의 래퍼런스만 전달한다.  
         - 배열이 전달되는 경우 -> 배열 래퍼런스만 매개 변수에 전달, 객체가 전달되는 경우와 동일  

메소드 오버로딩 - 한 클래스 내에서 두 개 이상의 이름이 같은 메소드 작성  

객체 치환 시 주의할 점 - 객체 지향은 객체 복사가 아니며, 래퍼런스의 복사이다.  

객체 소멸 - new에 의해 할당 받은 객체와 배열 메모리를 자바 가상 기계로 되돌려 주는 행위  
         - 소멸된 객체 공간은 가용 메모리에 포함  

자바에서 사용자 임의로 객체 소멸 안됨  
    - 자바는 객체 소멸 연산자 없음  
    - 객체 소멸은 자바 가상 기계의 고유한 역할  
    -자바 개발자에게는 매우 다행스러운 기능  

가비지 - 가르키는 래퍼런스가 하나도 없는 객체  
가비지 컬렉션 - 자바 가상 기계의 가비지 컬렉터가 자동으로 가비지 수집, 변환  
             - 자바 가상 기계가 가비지 자동 회수  
             가비지 컬렉터에 의해 자동 수행  
강제 가비지 컬렉션 강제 수행 - system 또는 rumntime객체의 gc() 메소드 호출하여 요청  

P.167  
패키지 - 상호 관련 있는 클래스 파일을 저장하여 관리하는 디렉터리  
      - 자바 응용프로그램은 하나 이상의 패키지로 구성  


## 3월 29일
P.55    
기본 타입 이외 리터럴 - null 리터럴, 문자열 리터럴(스트링 리터럴)
상수 선언 - final 키워드 사용, 선언 시 조깃값 지정, 실행 중 값 변경 불가

P.59
var키워드 - 타입을 생략하고 변수 선언 가능, 컴파일러가 추론하여 변수 타입 결정,
변수 선언 시 초깃값이 주어지지 않으면 컴파일 오류, var는 지역 변수 선언에만 한정

P.61
타입 변환 - 한 타입의 값을 다른 타입의 값으로 변환
자동 타입 변환 - 컴파일러의 의해 원래의 타입보다 큰 타입으로 자동 변환한다
강제 타입 변환 - 개발자의 의도적 타입 변환, ()안에 개발자가 명시적으로 타입 변환 지정
System.in - 키보드와 직접 연결되는 표준 입력 스트림 객체
scanner 클래스 - 읽은 바이트를 문자 정수 실수 문자열 등 다양한 타입으로 변환하여 리턴
    int nextInt(), string next() 자주 씀


P.66
식과 연산자
    연산자 - 주어진 식을 계산하여 결과를 얻어내는 과정
    증감 연산 - 1 증가 혹은 감소 시키는 연산
    대입 연산 - 연산의 오른쪽 결과는 왼쪽 변수에 대입
    비교 연산 - 두 개의 값을 비교하여 true/false 결과
    논리 연산 - 두 개의 논리 값에 논리 연산 논리 결과
    조건 연산 - 1개의 피연산자로 구성된 상항 연산자
    비트 연산 - 비트 논리 연산(비트끼리 AND,OR,XOR,NOT 연산), 비트 시프트 연산
    비트 논리 연산 - 피연산자의 각 비트들을 대상으로 하는 연산


P.78
조건문
중첩 if-else문
switch문 - 식과 case문의 값과 비교해서 일치하면 해당 case의 실행문장을 수행(break문을 만나면 switch문을 벗어남)
                                     일치하는 것이 없으면 default 문 실행(default문은 생략 가능)
case 문의 값 - (문자,정수,문자열 리터럴)만 허용, 실수 리터럴은 허용되지 않은


P.92
반복문 - 자바 반복문(for문, while문, do while문) for문을 가장 많이 사용함
while문 - 조건식이 참인 동안 반복 실행
continue문
break문

P.101
배열 - 인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료 구조
배열 선언 - 배열의 이름 선언
배열 생성 - 배열 공간 할당 받는 과정
배열 초기화 - 배열 생성과 값 초기화
배열 인덱스 - 배열의 인덱스는 0 ~ (배열크기 -1)  
자바의 배열은 객체로 처리 - 배열 객체의 lengh 필드





## 3월 22일
ctrl + shift + p --> java p --> create java project
루트에 있던 Hello를 src로 이동함

P.25 자바의 플랫폼 독립성, WORA - 한번 작성되고 컴파일된 자바 코드는 운영체제나 CPU 등 플랫폼에 상관없이 JVM만 있으면 어떤 컴퓨터에서든 동일하게 실행되는데 이것을 WORA라고 함

P.27 자바와 타 언어(C/C++)의 실행 차이 - C/C++은 같이 컴파일한 목적 파일을 링크시켜 하나의 실행파일을 만들며 
 실행파일 하나만 잇으면 실행이 가능함. 그러나 자바는 링크 과정이 없으며 자바 가상 기계가 컴파일된 클래스 파일을 실행함

P.28 JDK와 JRE - JDK는 자바 컴파일러 등의 개발 도구와 JRE로 구성됨. 우리는 javac를 많이 사용함. 
 자바 패키지 - 서로 관련된 클래스들을 분류하여 묶어 놓은 것, 계층구조로 되어 있음(클래스의 이름에 패키지 이름도 포함).
    
P.35 자바 통합 개발 환경, 이클립스 - IDE란? 통합 개발 환경, 편집, 컴파일, 디버깅을 한번에 할 수 잇는 통합된 개발 환경
    이클립스 - 자바 응용 프로그램 개발을 위한 통합 개발 환경, IBM에 의해 개발된 오픈 프로젝트
                                  



P.41 자바 응용의 종류 : 서블릿 응용프로그램 - 서블릿은 웹 서버에서 실행되는 서버용 자바 프로그램임
 EX)쇼핑몰이나 온라인 뱅킹 등등 구현

P.43 자바의 특성(1) - 플랫폼 독립성, 객체지향, 클래스로 캡슐화( 자바의 모든 변수나 함수는 클래스 내에 선언, 클래스    
 안에서 클래스(내부클래스) 작성 가능 ), 소스와 클래스 파일(하나의 소스 파일에 여러 클래스를 작성 가능)

P.45 자바의 특성(2) - 실행 코드 배포, 패키지, 멀티스레드, 가비지 컬렉션(사용하지 않는 메모리를 쓰레기통에 버림)

자바의 특성(3) - 실시간 응용프로그램에 부적합, 자바 프로그램은 안전, 프로그램 작성 쉬움, 실행 속도 개선을 위한 JIT 
 컴파일러 사용

2장 
2-1 설명
식별자란? - 클래스, 변수, 상수, 메소드 등에 붙이는 이름, 식별자의 원칙, 
대소문자 구별 - int barChart; 와 int barchart;는 서로 다른 식별자 선언
자바의 데이터 타입 - 기본타입 8개, 래퍼런스 타입 1개이며
문자열 - 문자열은 기본 타입이 아님, String클래스로 문자열 표현

변수와 선언
 변수 - 프로그램 실행 중에 값을 임시 저장하기 위한공간
 변수 선언 - 데이터 타입에서 정한 크기의 메모리 할당

리터럴과 정수 리터럴
 리터럴 - 프로그램에서 직접 표현한 값, 정수 실수 문자 논리 문자열 리터럴 있음
 정수 리터럴 - 10진수, 8진수, 16진수, 2진수 리터럴
 정수 리터럴은 int형으로 컴파일 

## 3월 15일
메세지를 안 쓰면 커밋이 안됨
커밋 메세지엔 영문으로 쓰는 게 좋고 한 일을 쓰면 됨 
ex - 강의 내용 정리

## 명령어 모음  
git config user.name "zkgh5"

git config user.email "rose55229@naver.com"

git config suerd.name

Create readme file
